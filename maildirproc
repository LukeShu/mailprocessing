#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""maildirproc -- Maildir processor.

This program is a sort-of replacement for procmail[1]. Like procmail,
it can be used for sorting email, but it is not a delivery agent. 
Instead it monitors existing maildir[2] mail boxes and performs
actions on already delivered mail.

Features:

  * Robust. Tries hard to never lose any mail, unless explictly
    forwarded or deleted by mail handling rules.
  * Simple, yet powerful. The mail processing logic is defined by a
    Python program instead of by cryptic rules. This means that it is
    easy to programmatically express custom mail handling behaviour.

Limitations:

  * Only works on maildir[2] mail boxes.
  * Not a delivery agent, so it can't be used to bounce or rewrite
    incoming mail.

maildirproc was inspired by maildird[3], written by Jörgen Cederlöf.

Joel Rosdahl <joel@rosdahl.net>

---
[1] http://www.procmail.org
[2] http://en.wikipedia.org/wiki/Maildir
[3] http://www.lysator.liu.se/~jc/maildird.html
"""

import email.Header
import email.Parser
import os
import re
import sha
import shutil
import socket
import subprocess
import sys
import time
from optparse import OptionParser


def sha1sum(path):
    fp = open(path)
    sha_obj = sha.new()
    while True:
        data = fp.read(4096)
        if not data:
            break
        sha_obj.update(data)
    return sha_obj.hexdigest()


class MailHeader(object):
    def __init__(self, mail, name, text):
        self._mail = mail
        self._name = name
        self._text = text

    def __str__(self):
        return self._text

    def __repr__(self):
        return repr(self._text)

    def contains(self, string):
        result = string.lower() in self._text.lower()
        if result:
            result_text = "contains"
        else:
            result_text = "does not contain"
        self._mail._processor.log(
            "--> Header \"%s\" %s %r" % (self._name, result_text, string))
        return result

    def matches(self, regexp):
        result = re.match(regexp, self._text, re.IGNORECASE | re.MULTILINE)
        if result:
            result_text = "matches"
        else:
            result_text = "does not match"
        self._mail._processor.log(
            "--> Header \"%s\" %s match %r" % (
            self._name, result_text, regexp))
        return result


class MailTarget(object):
    _target_headers = ["cc", "to"]

    def __init__(self, mail):
        self._mail = mail

    def contains(self, string):
        result = self._helper("contains", string)
        if result:
            result_text = "contains"
        else:
            result_text = "does not contain"
        self._mail._processor.log(
            "--> Target %s %r" % (result_text, string))
        return result

    def matches(self, regexp):
        result = self._helper("matches", regexp)
        if result:
            result_text = "matches"
        else:
            result_text = "does not match"
        self._mail._processor.log(
            "--> Target %s match %r" % (result_text, string))
        return result

    # ----------------------------------------------------------------

    def _helper(self, method_name, arg):
        for header in self._target_headers:
            m = getattr(self._mail[header], method_name)
            if m(arg):
                return True
        return False


class MailBase(object):
    def __init__(self, processor, maildir, mail_path):
        self._processor = processor
        self._maildir = maildir
        self._path = mail_path
        self._target = MailTarget(self)
        self._headers = {}
        self._parse_mail()
        self._log_processing()

    def get_maildir(self):
        return self._maildir
    maildir = property(get_maildir)

    def get_path(self):
        return self._path
    path = property(get_path)

    def get_target(self):
        return self._target
    target = property(get_target)

    def __getitem__(self, header_name):
        return MailHeader(
            self, header_name, self._headers.get(header_name.lower(), ""))

    def from_mailing_list(self, list_name):
        list_name = list_name.lower()
        for headername in [
                "Delivered-To", "X-BeenThere", "X-Mailing-List"]:
            if list_name in self._headers.get(headername, ""):
                return True
        return False

    # ----------------------------------------------------------------

    def _log_processing(self):
        self._processor.log("")
        self._processor.log("Handling mail %s:" % self.path)
        self._processor.log("Message-ID: %r" % self["Message-ID"])
        self._processor.log("SHA1:       %r" % sha1sum(self.path))
        self._processor.log("Subject:    %r" % self["Subject"])
        self._processor.log("Date:       %r" % self["Date"])
        self._processor.log("From:       %r" % self["From"])
        self._processor.log("To:         %r" % self["To"])
        self._processor.log("Cc:         %r" % self["Cc"])

    def _parse_mail(self):
        try:
            fp = open(self.path)
        except IOError, e:
            # The file was probably moved by someone else.
            self._processor._err("Error opening %s: %s" % (path, e))
            return
        headers = email.Parser.Parser().parse(fp, headersonly=True)
        fp.close()
        for name in headers.keys():
            for header in headers.get_all(name, []):
                value_parts = [
                    x for (x, y) in email.Header.decode_header(header)]
                value = "\n".join(value_parts)
                self._headers[name.lower()] = value


class DryRunMail(MailBase):
    def copy(self, maildir):
        self._processor.log("==> Copying to %s" % maildir)

    def delete(self):
        self._processor.log("==> Deleting")

    def forward(self, addresses):
        self._forward(True, address)

    def forward_copy(self, addresses):
        self._forward(False, addresses)

    def move(self, maildir):
        self._processor.log("==> Moving to %s" % maildir)

    # ----------------------------------------------------------------

    def _forward(self, delete, addresses):
        if isinstance(addresses, basestring):
            addresses = [addresses]
        else:
            addresses = list(addresses)
        if not delete:
            copy = " copy"
        else:
            copy = ""
        self._processor.log("==> Forwarding%s to %r" % (copy, addresses))


class Mail(MailBase):
    def copy(self, maildir):
        self._processor.log("==> Copying to %s" % maildir)
        self._copy(maildir)

    def delete(self):
        self._processor.log("==> Deleting")
        self._delete()

    def forward(self, addresses):
        self._forward(True, address)

    def forward_copy(self, addresses):
        self._forward(False, addresses)

    def move(self, maildir):
        self._processor.log("==> Moving to %s" % maildir)
        target = os.path.join(
            self._processor.maildir_base,
            maildir,
            "new",
            self._processor._create_maildir_name())
        self._processor._rename(self.path, target)

    # ----------------------------------------------------------------

    def _copy(self, maildir):
        try:
            source_fp = open(self.path)
        except IOError, e:
            # The file was probably moved.
            self._err("Error opening %s: %s" % (self.path, e))
            return False

        tmp_target = os.path.join(
            self._processor.maildir_base,
            maildir,
            "tmp",
            self._processor._create_maildir_name())
        tmp_target_fp = os.fdopen(
            os.open(tmp_target, os.O_WRONLY | os.O_CREAT | os.O_EXCL),
            "w")
        try:
            shutil.copyfileobj(source_fp, tmp_target_fp)
        except IOError, e:
            self._processor._err(
                "Error copying %s to: %s" % (self.path, tmp_target, e))
            return False
        source_fp.close()
        tmp_target_fp.close()

        self._processor._rename(tmp_target, target)

    def _delete(self):
        try:
            os.unlink(self.path)
        except OSError, e:
            # The file was probably moved.
            self._processor._err("Error unlinking %s: %s" % (self.path, e))

    def _forward(self, delete, addresses):
        if isinstance(addresses, basestring):
            addresses = [addresses]
        else:
            addresses = list(addresses)
        if not delete:
            copy = " copy"
        else:
            copy = ""
        self._processor.log("==> Forwarding%s to %r" % (copy, addresses))
        try:
            source_fp = open(self.path)
        except IOError, e:
            # The file was probably moved.
            self._processor._err("Error opening %s: %s" % (self.path, e))
            return

        p = subprocess.Popen(
            ["/usr/sbin/sendmail", "-i", "--"] + addresses,
            stdin=subprocess.PIPE)
        shutil.copyfileobj(source_fp, p.stdin)
        p.stdin.close()
        p.wait()
        source_fp.close()

        if delete:
            self._delete()


class MaildirProcessor(object):
    def __init__(self, log_fp=sys.stdout, dry_run=False, run_once=False):
        self._log_fp = log_fp
        self._run_once = run_once or dry_run
        self._maildir_base = None
        self._deliveries = 0
        self._maildirs = []
        if dry_run:
            self._mail_class = DryRunMail
        else:
            self._mail_class = Mail

    def set_logfile(self, path_or_fp):
        if isinstance(path_or_fp, basestring):
            self._log_fp = open(os.path.expanduser(path_or_fp), "a")
        else:
            self._log_fp = path_or_fp
    logfile = property(fset=set_logfile)

    def get_maildir_base(self):
        return self._maildir_base
    def set_maildir_base(self, path):
        self._maildir_base = os.path.expanduser(path)
    maildir_base = property(get_maildir_base, set_maildir_base)

    def get_maildirs(self):
        return self._maildirs
    def set_maildirs(self, maildirs):
        self._maildirs = maildirs
    maildirs = property(get_maildirs, set_maildirs)

    def __iter__(self):
        self.log("")
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S %Z")
        self.log("Starting maildirproc at %s" % timestamp)

        if self.maildir_base is None:
            self._err("Maildir base directory not set")
            return

        if not self._maildirs:
            self._err("No maildirs to process")
            return

        mtime_map = {}
        while True:
            for maildir in self._maildirs:
                maildir_path = os.path.join(self._maildir_base, maildir)
                for subdir in ["cur", "new"]:
                    subdir_path = os.path.join(maildir_path, subdir)
                    cur_mtime = os.path.getmtime(subdir_path)
                    if cur_mtime != mtime_map.setdefault(subdir_path, 0):
                        if cur_mtime < int(time.time()):
                            # If cur_mtime == int(time.time()) we
                            # can't be sure that everything has been
                            # processed; a new mail may be delivered
                            # later the same second.
                            mtime_map[subdir_path] = cur_mtime
                        for mail_file in os.listdir(subdir_path):
                            mail_path = os.path.join(subdir_path, mail_file)
                            yield self._mail_class(self, maildir, mail_path)
            if self._run_once:
                break
            time.sleep(1)

    def log(self, text):
        self._log_fp.write("%s\n" % text)
        self._log_fp.flush()

    # ----------------------------------------------------------------

    def _create_maildir_name(self):
        """Create and return a unique name for a Maildir message."""
        hostname = socket.gethostname()
        hostname = hostname.replace("/", "\\057")
        hostname = hostname.replace(":", "\\072")
        now = time.time()
        delivery_identifier = "M%dP%dQ%d" % (
            round((now - int(now)) * 1000000),
            os.getpid(),
            self._deliveries)
        self._deliveries += 1
        return "%d.%s.%s" % (now, delivery_identifier, hostname)

    def _err(self, text):
        self.log("Error: %s" % text)
        sys.stderr.write("maildirproc: Error: %s\n" % text)

    def _rename(self, source, target):
        try:
            os.rename(source, target)
        except OSError, e:
            self._err("Error renaming %s to %s: %s" % (source, target, e))

######################################################################

def main(argv):
#    default_rcfile_location = "~/.maildirprocrc"
    default_rcfile_location = "xxx"
    parser = OptionParser(version="0.1")
    parser.add_option(
        "-b",
        "--maildir-base",
        type="string",
        dest="maildir_base",
        metavar="DIRECTORY",
        help="set maildir base directory")
    parser.add_option(
        "--dry-run",
        action="store_true",
        default=False,
        help="just log what should have been done; implies --once")
    parser.add_option(
        "-l",
        "--logfile",
        type="string",
        dest="logfile",
        metavar="FILE",
        help="send log to LOGFILE instead of standard output",
        default=None)
    parser.add_option(
        "-m",
        "--maildir",
        action="append",
        type="string",
        default=[],
        dest="maildirs",
        metavar="NAME",
        help=(
            "add NAME (a subdirectory of the maildir base directory) to the"
            " set of maildir directories to process"))
    parser.add_option(
        "--once",
        action="store_true",
        default=False,
        help="only process the maildirs once and then exit")
    parser.add_option(
        "-r",
        "--rcfile",
        type="string",
        dest="rcfile",
        metavar="FILE",
        help=(
            "use the given rc file instead of the default (%s)" % (
                default_rcfile_location)),
        default=default_rcfile_location)
    (options, args) = parser.parse_args(argv[1:])

    rcfile_path = os.path.expanduser(options.rcfile)
    if options.logfile is None:
        log_fp = sys.stdout
    else:
        log_fp = open(os.path.expanduser(options.logfile), "a")

    processor = MaildirProcessor(log_fp, options.dry_run)
    if options.maildir_base:
        processor.set_maildir_base(options.maildir_base)
    if options.maildirs:
        processor.set_maildirs(options.maildirs)
    environment = {"processor": processor}
    try:
        fp = open(rcfile_path)
    except IOError, e:
        processor._err("Could not open RC file: %s" % e)
    else:
        exec fp in environment


if __name__ == "__main__":
    try:
        main(sys.argv)
    except KeyboardInterrupt:
        pass
