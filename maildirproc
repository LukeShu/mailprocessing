#! /usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2006 Joel Rosdahl <joel@rosdahl.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

"""maildirproc -- maildir processor

http://joel.rosdahl.net/maildirproc/

maildirproc is a small program that processes one or several existing
mail boxes in the maildir format. It is primarily focused on mail
sorting -- i.e., moving, copying, forwarding and deleting mail
according to a set of rules. It can be seen as an alternative to
procmail, but instead of being a delivery agent (which wants to be
part of the delivery chain), maildirproc only processes already
delivered mail.
"""


import os
import random
import re
import sha
import shutil
import socket
import subprocess
import sys
import time
from email import Errors as email_errors
from email import Header as email_header
from email import Parser as email_parser
from optparse import OptionParser


def offset_to_timezone(offset):
    if offset <= 0:
        sign = "+"
        offset = -offset
    else:
        sign = "-"
    return "%s%02d%02d" % (
        sign,
        offset / 3600,
        (offset % 3600) / 60)


def iso_8601_now():
    now = time.time()
    microseconds = (1000 * (now - int(now)))
    first = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(now))
    return "%s.%03d %s" % (
        first,
        microseconds,
        offset_to_timezone(time.altzone))


def sha1sum(fp):
    sha_obj = sha.new()
    while True:
        data = fp.read(4096)
        if not data:
            break
        sha_obj.update(data)
    return sha_obj.hexdigest()


class MailHeader(object):
    def __init__(self, mail, name, text):
        self._mail = mail
        self._name = name
        self._text = text

    def __str__(self):
        return self._text

    def __repr__(self):
        return repr(self._text)

    def contains(self, string):
        result = string.lower() in self._text.lower()
        if result:
            result_text = "contains"
        else:
            result_text = "does not contain"
        self._mail.processor.log_debug(
            "... Header \"%s\" %s %r" % (self._name, result_text, string))
        return result

    def matches(self, regexp):
        result = re.search(regexp, self._text, re.IGNORECASE | re.MULTILINE)
        if result:
            result_text = "matches"
        else:
            result_text = "does not match"
        self._mail.processor.log_debug(
            "... Header \"%s\" %s match %r" % (
                self._name, result_text, regexp))
        return result


class MailTarget(object):
    _target_headers = ["to", "cc"]

    def __init__(self, mail):
        self._mail = mail

    def contains(self, string):
        result = self._helper("contains", string)
        if result:
            result_text = "contains"
        else:
            result_text = "does not contain"
        self._mail.processor.log_debug(
            "... Target %s %r" % (result_text, string))
        return result

    def matches(self, regexp):
        result = self._helper("matches", regexp)
        if result:
            result_text = "matches"
        else:
            result_text = "does not match"
        self._mail.processor.log_debug(
            "... Target %s match %r" % (result_text, regexp))
        return result

    # ----------------------------------------------------------------

    def _helper(self, method_name, arg):
        for header in self._target_headers:
            m = getattr(self._mail[header], method_name)
            if m(arg):
                return True
        return False


class MailBase(object):
    def __init__(self, processor, maildir, mail_path):
        self._processor = processor
        self._maildir = maildir
        self._path = mail_path
        self._target = MailTarget(self)
        self._headers = {}
        if self._parse_mail():
            self._log_processing()

    def get_maildir(self):
        return self._maildir
    maildir = property(get_maildir)

    def get_path(self):
        return self._path
    path = property(get_path)

    def get_processor(self):
        return self._processor
    processor = property(get_processor)

    def get_target(self):
        return self._target
    target = property(get_target)

    def __getitem__(self, header_name):
        return MailHeader(
            self, header_name, self._headers.get(header_name.lower(), ""))

    def from_mailing_list(self, list_name):
        list_name = list_name.lower()
        for headername in [
                "delivered-to", "mailing-list", "x-beenthere",
                "x-mailing-list"]:
            if self[headername].contains(list_name):
                self._processor.log_debug(
                    "... Mail is on mailing list %s" % list_name)
                return True
        self._processor.log_debug(
            "... Mail is not on mailing list %s" % list_name)
        return False

    # ----------------------------------------------------------------

    def _log_processing(self):
        self._processor.log("")
        self._processor.log("New mail detected at %s:" % iso_8601_now())
        self._processor.log("Path:       %r" % self.path)
        try:
            fp = open(self.path)
        except IOError, e:
            # The file was probably (re)moved by some other process.
            self._processor.log_mail_opening_error(self.path, e)
            return
        self._processor.log("SHA1:       %r" % sha1sum(fp))
        self._processor.log("Message-ID: %r" % self["Message-ID"])
        self._processor.log("Subject:    %r" % self["Subject"])
        self._processor.log("Date:       %r" % self["Date"])
        self._processor.log("From:       %r" % self["From"])
        self._processor.log("To:         %r" % self["To"])
        self._processor.log("Cc:         %r" % self["Cc"])

    def _parse_mail(self):
        try:
            fp = open(self.path)
        except IOError, e:
            # The file was probably (re)moved by some other process.
            self._processor.log_mail_opening_error(self.path, e)
            return False
        headers = email_parser.Parser().parse(fp, headersonly=True)
        fp.close()
        for name in headers.keys():
            for header in headers.get_all(name, []):
                try:
                    value_parts = [
                        x for (x, _) in email_header.decode_header(header)]
                    value = "\n".join(value_parts)
                except (email_errors.HeaderParseError, ValueError):
                    self._processor.log_error(
                        "Error: Could not decode header %r" % header)
                    value = header.encode()
                self._headers[name.lower()] = value
        return True


class DryRunMail(MailBase):
    def copy(self, maildir):
        self._processor.log("==> Copying to %s" % maildir)

    def delete(self):
        self._processor.log("==> Deleting")

    def forward(self, addresses):
        self._forward(True, addresses)

    def forward_copy(self, addresses):
        self._forward(False, addresses)

    def move(self, maildir):
        self._processor.log("==> Moving to %s" % maildir)

    # ----------------------------------------------------------------

    def _forward(self, delete, addresses):
        if isinstance(addresses, basestring):
            addresses = [addresses]
        else:
            addresses = list(addresses)
        if not delete:
            copy = " copy"
        else:
            copy = ""
        self._processor.log("==> Forwarding%s to %r" % (copy, addresses))


class Mail(MailBase):
    def copy(self, maildir):
        self._processor.log("==> Copying to %s" % maildir)
        self._copy(maildir)

    def delete(self):
        self._processor.log("==> Deleting")
        self._delete()

    def forward(self, addresses):
        self._forward(True, addresses)

    def forward_copy(self, addresses):
        self._forward(False, addresses)

    def move(self, maildir):
        self._processor.log("==> Moving to %s" % maildir)
        flagpart = self._get_flagpart()
        target = os.path.join(
            self._processor.maildir_base,
            maildir,
            self.path.split(os.sep)[-2], # new/cur
            self._processor.create_maildir_name() + flagpart)
        self._processor.rename(self.path, target)

    # ----------------------------------------------------------------

    def _copy(self, maildir):
        try:
            source_fp = open(self.path)
        except IOError, e:
            # The file was probably (re)moved by some other process.
            self._processor.log_mail_opening_error(self.path, e)
            return

        tmp_target = os.path.join(
            self._processor.maildir_base,
            maildir,
            "tmp",
            self._processor.create_maildir_name())
        try:
            tmp_target_fp = os.fdopen(
                os.open(tmp_target, os.O_WRONLY | os.O_CREAT | os.O_EXCL),
                "w")
        except IOError, e:
            self._processor.log_io_error(
                "Could not open %s for writing" % tmp_target,
                e)
            return
        try:
            shutil.copyfileobj(source_fp, tmp_target_fp)
            source_fp.close()
            tmp_target_fp.close()
        except IOError, e:
            self._processor.log_io_error(
                "Could not copy %s to %s" % (self.path, tmp_target),
                e)
            return

        flagpart = self._get_flagpart()
        target = os.path.join(
            self._processor.maildir_base,
            maildir,
            self.path.split(os.sep)[-2], # new/cur
            self._processor.create_maildir_name() + flagpart)
        try:
            self._processor.rename(tmp_target, target)
        except IOError, e:
            self._processor.log_io_error(
                "Could not rename %s to %s" % (tmp_target, target),
                e)
            return

    def _delete(self):
        try:
            os.unlink(self.path)
        except OSError, e:
            # The file was probably moved.
            self._processor.log_io_error(
                "Could not delete %s; some other process probably (re)moved"
                " it" % self.path,
                e)

    def _forward(self, delete, addresses):
        if isinstance(addresses, basestring):
            addresses = [addresses]
        else:
            addresses = list(addresses)
        if delete:
            copy = ""
        else:
            copy = " copy"
        self._processor.log("==> Forwarding%s to %r" % (copy, addresses))
        try:
            source_fp = open(self.path)
        except IOError, e:
            # The file was probably moved.
            self._processor.log_mail_opening_error(self.path, e)
            return

        p = subprocess.Popen(
            "%s %s -- %s" % (
                self._processor.sendmail,
                self._processor.sendmail_flags,
                " ".join(addresses)
                ),
            shell=True,
            stdin=subprocess.PIPE)
        shutil.copyfileobj(source_fp, p.stdin)
        p.stdin.close()
        p.wait()
        source_fp.close()

        if delete:
            self._delete()

    def _get_flagpart(self):
        parts = os.path.basename(self.path).split(":2,")
        if len(parts) == 2:
            return ":2," + parts[1]
        else:
            return ""


class MaildirProcessor(object):
    def __init__(
            self, rcfile, log_fp, log_level=1, dry_run=False, run_once=False,
            auto_reload_rcfile=False):
        self._rcfile = rcfile
        self._log_fp = log_fp
        self._log_level = log_level
        self._run_once = run_once or dry_run
        self._auto_reload_rcfile = auto_reload_rcfile
        self._maildir_base = None
        self._deliveries = 0
        self._maildirs = []
        self._sendmail = "/usr/sbin/sendmail"
        self._sendmail_flags = "-i"
        self.rcfile_modified = False
        self._previous_rcfile_mtime = self._get_previous_rcfile_mtime()
        if dry_run:
            self._mail_class = DryRunMail
        else:
            self._mail_class = Mail

    def get_auto_reload_rcfile(self):
        return self._auto_reload_rcfile
    def set_auto_reload_rcfile(self, value):
        self._auto_reload_rcfile = value
    auto_reload_rcfile = property(
        get_auto_reload_rcfile, set_auto_reload_rcfile)

    def set_logfile(self, path_or_fp):
        if isinstance(path_or_fp, basestring):
            self._log_fp = open(os.path.expanduser(path_or_fp), "a")
        else:
            self._log_fp = path_or_fp
    logfile = property(fset=set_logfile)

    def get_maildir_base(self):
        return self._maildir_base
    def set_maildir_base(self, path):
        self._maildir_base = os.path.expanduser(path)
    maildir_base = property(get_maildir_base, set_maildir_base)

    def get_maildirs(self):
        return self._maildirs
    def set_maildirs(self, maildirs):
        self._maildirs = maildirs
    maildirs = property(get_maildirs, set_maildirs)

    def get_rcfile(self):
        return self._rcfile
    rcfile = property(get_rcfile)

    def get_sendmail(self):
        return self._sendmail
    def set_sendmail(self, sendmail):
        self._sendmail = sendmail
    sendmail = property(get_sendmail, set_sendmail)

    def get_sendmail_flags(self):
        return self._sendmail_flags
    def set_sendmail_flags(self, sendmail_flags):
        self._sendmail_flags = sendmail_flags
    sendmail_flags = property(get_sendmail_flags, set_sendmail_flags)

    def __iter__(self):
        if not self._maildirs:
            self.fatal_error("Error: No maildirs to process")

        self.rcfile_modified = False
        mtime_map = {}
        while True:
            if self.auto_reload_rcfile:
                current_rcfile_mtime = self._get_previous_rcfile_mtime()
                if current_rcfile_mtime != self._previous_rcfile_mtime:
                    self._previous_rcfile_mtime = current_rcfile_mtime
                    self.rcfile_modified = True
                    self.log_info("Detected modified RC file; reloading")
                    break
            for maildir in self._maildirs:
                maildir_path = os.path.join(self._maildir_base, maildir)
                for subdir in ["cur", "new"]:
                    subdir_path = os.path.join(maildir_path, subdir)
                    cur_mtime = os.path.getmtime(subdir_path)
                    if cur_mtime != mtime_map.setdefault(subdir_path, 0):
                        if cur_mtime < int(time.time()):
                            # If cur_mtime == int(time.time()) we
                            # can't be sure that everything has been
                            # processed; a new mail may be delivered
                            # later the same second.
                            mtime_map[subdir_path] = cur_mtime
                        for mail_file in os.listdir(subdir_path):
                            mail_path = os.path.join(subdir_path, mail_file)
                            yield self._mail_class(self, maildir, mail_path)
            if self._run_once:
                break
            time.sleep(1)

    def log(self, text, level=1):
        if level <= self._log_level:
            self._log_fp.write("%s\n" % text)
            self._log_fp.flush()

    def log_debug(self, text):
        self.log(text, 2)

    def log_error(self, text):
        self.log(text, 0)

    def log_info(self, text):
        self.log(text, 1)

    def fatal_error(self, text):
        self.log_error(text)
        sys.stderr.write("%s\n" % text)
        sys.exit(1)

    # ----------------------------------------------------------------
    # Interface used by MailBase and descendants:

    def create_maildir_name(self):
        """Create and return a unique name for a Maildir message."""
        hostname = socket.gethostname()
        hostname = hostname.replace("/", "\\057")
        hostname = hostname.replace(":", "\\072")
        now = time.time()
        delivery_identifier = "M%dP%dQ%dR%08x" % (
            round((now - int(now)) * 1000000),
            os.getpid(),
            self._deliveries,
            random.randint(0, 0xffffffff))
        self._deliveries += 1
        return "%d.%s.%s" % (now, delivery_identifier, hostname)

    def log_io_error(self, errmsg, os_errmsg):
        self.log_error(
            "Error: %s (error message from OS: %s)" % (errmsg, os_errmsg))

    def log_mail_opening_error(self, path, errmsg):
        self.log_io_error(
            "Could not open %s; some other process probably (re)moved it" % (
                path),
            errmsg)

    def rename(self, source, target):
        try:
            os.rename(source, target)
        except OSError, e:
            self.log_error(
                "Error: Could not rename %s to %s: %s" % (source, target, e))


    # ----------------------------------------------------------------
    # Private methods:

    def _get_previous_rcfile_mtime(self):
        if self.rcfile == "-":
            return None
        else:
            try:
                return os.path.getmtime(self.rcfile)
            except OSError:
                # File does not exist.
                return None

######################################################################

def main(argv):
    maildirproc_directory = "~/.maildirproc"
    default_rcfile_location = os.path.join(maildirproc_directory, "default.rc")
    default_logfile_location = os.path.join(maildirproc_directory, "log")

    if not os.path.isdir(os.path.expanduser(maildirproc_directory)):
        os.mkdir(os.path.expanduser(maildirproc_directory))

    parser = OptionParser(
        version="0.2",
        description=(
            "maildirproc is a program that scans a number of maildir mail"
            " boxes and processes found mail as defined by an rc file. See"
            " http://joel.rosdahl.net/maildirproc/ for more information."))
    parser.add_option(
        "--auto-reload-rcfile",
        action="store_true",
        default=False,
        help=(
            "turn on automatic reloading of the rc file when it has been"
            " modified"))
    parser.add_option(
        "--dry-run",
        action="store_true",
        default=False,
        help=(
            "just log what should have been done; implies --once"))
    parser.add_option(
        "-l",
        "--logfile",
        type="string",
        dest="logfile",
        metavar="FILE",
        help="send log to FILE instead of the default (%s)" % (
            default_logfile_location),
        default=default_logfile_location)
    parser.add_option(
        "--log-level",
        type="int",
        metavar="INTEGER",
        help=(
            "only include log messages with this log level or lower; defaults"
            " to 1"),
        default=1)
    parser.add_option(
        "-m",
        "--maildir",
        action="append",
        type="string",
        default=[],
        dest="maildirs",
        metavar="DIRECTORY",
        help=(
            "add DIRECTORY to the set of maildir directories to process (can"
            " be passed multiple times); if DIRECTORY is relative, it is"
            " relative to the maildir base directory"))
    parser.add_option(
        "-b",
        "--maildir-base",
        type="string",
        default=".",
        dest="maildir_base",
        metavar="DIRECTORY",
        help="set maildir base directory; defaults to the current working"
             " directory")
    parser.add_option(
        "--once",
        action="store_true",
        default=False,
        help=(
            "only process the maildirs once and then exit; without this flag,"
            " maildirproc will scan the maildirs continuously"))
    parser.add_option(
        "-r",
        "--rcfile",
        type="string",
        dest="rcfile",
        metavar="FILE",
        help=(
            "use the given rc file instead of the default (%s)" % (
                default_rcfile_location)),
        default=default_rcfile_location)
    parser.add_option(
        "--test",
        action="store_true",
        default=False,
        help=(
            "test mode; implies --dry-run, --once, --logfile=- and"
            " --verbose"))
    parser.add_option(
        "-v",
        "--verbose",
        action="count",
        default=0,
        dest="verbosity",
        help="increase log level one step")
    (options, _) = parser.parse_args(argv[1:])

    if options.test:
        options.dry_run = True
        options.logfile = "-"
        options.verbosity = max(1, options.verbosity)

    if options.dry_run:
        options.once = True

    if options.logfile == "-":
        log_fp = sys.stdout
    else:
        log_fp = open(os.path.expanduser(options.logfile), "a")

    log_level = options.log_level + options.verbosity

    rcfile = os.path.expanduser(options.rcfile)
    processor = MaildirProcessor(
        rcfile, log_fp, log_level, options.dry_run, options.once,
        options.auto_reload_rcfile)
    processor.log("")
    processor.log(
        "Starting maildirproc %s at %s" % (parser.version, iso_8601_now()))

    processor.maildir_base = options.maildir_base
    if options.maildirs:
        processor.maildirs = options.maildirs
    if "SENDMAIL" in os.environ:
        processor.sendmail = os.environ["SENDMAIL"]
    if "SENDMAILFLAGS" in os.environ:
        processor.sendmail_flags = os.environ["SENDMAILFLAGS"]
    environment = {"processor": processor}

    if rcfile == "-":
        processor.log("RC file: <standard input>")
        fp = sys.stdin
        exec fp in environment
    else:
        processor.log("RC file: %r" % rcfile)
        while True:
            try:
                fp = open(rcfile)
            except IOError, e:
                processor.fatal_error("Error: Could not open RC file: %s" % e)
            else:
                exec fp in environment
                if not processor.rcfile_modified:
                    # Normal exit.
                    break
                # We should reload the RC file.


if __name__ == "__main__":
    try:
        main(sys.argv)
    except KeyboardInterrupt:
        pass
