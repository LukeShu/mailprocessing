#! /usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (C) 2006 Joel Rosdahl <joel@rosdahl.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

"""maildirproc -- maildir processor

If

  * you want to automatically sort your e-mail using some given logic,
  * you use maildir[2] mail boxes,
  * you use (or consider using) procmail for the task, but
    - you think it's too terse, or
    - you think it's too ugly, or
    - you think it's too limited, or
    - you just want an alternative,
  * you don't need or want a delivery agent but instead something that
    acts on already delivered mail,
  * you want something simple and robust yet powerful,
  * you want to express the mail processing logic in an imperative
    language (Python) instead of in declarative rules,
  * you want to be able to write custom mail handling logic (in
    Python) without the need to write external programs,

then maildirproc may be for you.

maildirproc was inspired by maildird[3], written by Jörgen Cederlöf.

---
[1] http://www.procmail.org
[2] http://en.wikipedia.org/wiki/Maildir
[3] http://www.lysator.liu.se/~jc/maildird.html
"""


import email.Header
import email.Parser
import os
import re
import sha
import shutil
import socket
import subprocess
import sys
import time
from optparse import OptionParser


def iso_8601_now():
    return time.strftime("%Y-%m-%d %H:%M:%S %Z")


def sha1sum(path):
    fp = open(path)
    sha_obj = sha.new()
    while True:
        data = fp.read(4096)
        if not data:
            break
        sha_obj.update(data)
    return sha_obj.hexdigest()


class MailHeader(object):
    def __init__(self, mail, name, text):
        self._mail = mail
        self._name = name
        self._text = text

    def __str__(self):
        return self._text

    def __repr__(self):
        return repr(self._text)

    def contains(self, string):
        result = string.lower() in self._text.lower()
        if result:
            result_text = "contains"
        else:
            result_text = "does not contain"
        self._mail._processor.log(
            "--> Header \"%s\" %s %r" % (self._name, result_text, string))
        return result

    def matches(self, regexp):
        result = re.search(regexp, self._text, re.IGNORECASE | re.MULTILINE)
        if result:
            result_text = "matches"
        else:
            result_text = "does not match"
        self._mail._processor.log(
            "--> Header \"%s\" %s match %r" % (
            self._name, result_text, regexp))
        return result


class MailTarget(object):
    _target_headers = ["to", "cc"]

    def __init__(self, mail):
        self._mail = mail

    def contains(self, string):
        result = self._helper("contains", string)
        if result:
            result_text = "contains"
        else:
            result_text = "does not contain"
        self._mail._processor.log(
            "--> Target %s %r" % (result_text, string))
        return result

    def matches(self, regexp):
        result = self._helper("matches", regexp)
        if result:
            result_text = "matches"
        else:
            result_text = "does not match"
        self._mail._processor.log(
            "--> Target %s match %r" % (result_text, regexp))
        return result

    # ----------------------------------------------------------------

    def _helper(self, method_name, arg):
        for header in self._target_headers:
            m = getattr(self._mail[header], method_name)
            if m(arg):
                return True
        return False


class MailBase(object):
    def __init__(self, processor, maildir, mail_path):
        self._processor = processor
        self._maildir = maildir
        self._path = mail_path
        self._target = MailTarget(self)
        self._headers = {}
        if self._parse_mail():
            self._log_processing()

    def get_maildir(self):
        return self._maildir
    maildir = property(get_maildir)

    def get_path(self):
        return self._path
    path = property(get_path)

    def get_target(self):
        return self._target
    target = property(get_target)

    def __getitem__(self, header_name):
        return MailHeader(
            self, header_name, self._headers.get(header_name.lower(), ""))

    def from_mailing_list(self, list_name):
        list_name = list_name.lower()
        result = False
        for headername in [
                "delivered-to", "x-beenthere", "x-mailing-list"]:
            if self[headername].contains(list_name):
                return True
        return False

    # ----------------------------------------------------------------

    def _log_processing(self):
        self._processor.log("")
        self._processor.log("New mail detected at %s:" % iso_8601_now())
        self._processor.log("Path:       %r" % self.path)
        self._processor.log("SHA1:       %r" % sha1sum(self.path))
        self._processor.log("Message-ID: %r" % self["Message-ID"])
        self._processor.log("Subject:    %r" % self["Subject"])
        self._processor.log("Date:       %r" % self["Date"])
        self._processor.log("From:       %r" % self["From"])
        self._processor.log("To:         %r" % self["To"])
        self._processor.log("Cc:         %r" % self["Cc"])

    def _parse_mail(self):
        try:
            fp = open(self.path)
        except IOError, e:
            # The file was probably moved by someone else.
            self._processor.log("Error: Could not open %s: %s" % (path, e))
            return False
        headers = email.Parser.Parser().parse(fp, headersonly=True)
        fp.close()
        for name in headers.keys():
            for header in headers.get_all(name, []):
                value_parts = [
                    x for (x, y) in email.Header.decode_header(header)]
                value = "\n".join(value_parts)
                self._headers[name.lower()] = value
        return True


class DryRunMail(MailBase):
    def copy(self, maildir):
        self._processor.log("==> Copying to %s" % maildir)

    def delete(self):
        self._processor.log("==> Deleting")

    def forward(self, addresses):
        self._forward(True, address)

    def forward_copy(self, addresses):
        self._forward(False, addresses)

    def move(self, maildir):
        self._processor.log("==> Moving to %s" % maildir)

    # ----------------------------------------------------------------

    def _forward(self, delete, addresses):
        if isinstance(addresses, basestring):
            addresses = [addresses]
        else:
            addresses = list(addresses)
        if not delete:
            copy = " copy"
        else:
            copy = ""
        self._processor.log("==> Forwarding%s to %r" % (copy, addresses))


class Mail(MailBase):
    def copy(self, maildir):
        self._processor.log("==> Copying to %s" % maildir)
        self._copy(maildir)

    def delete(self):
        self._processor.log("==> Deleting")
        self._delete()

    def forward(self, addresses):
        self._forward(True, addresses)

    def forward_copy(self, addresses):
        self._forward(False, addresses)

    def move(self, maildir):
        self._processor.log("==> Moving to %s" % maildir)
        target = os.path.join(
            self._processor.maildir_base,
            maildir,
            "new",
            self._processor._create_maildir_name())
        self._processor._rename(self.path, target)

    # ----------------------------------------------------------------

    def _copy(self, maildir):
        try:
            source_fp = open(self.path)
        except IOError, e:
            # The file was probably moved.
            self.log("Error: Could not open %s: %s" % (self.path, e))
            return False

        tmp_target = os.path.join(
            self._processor.maildir_base,
            maildir,
            "tmp",
            self._processor._create_maildir_name())
        tmp_target_fp = os.fdopen(
            os.open(tmp_target, os.O_WRONLY | os.O_CREAT | os.O_EXCL),
            "w")
        try:
            shutil.copyfileobj(source_fp, tmp_target_fp)
        except IOError, e:
            self._processor.log(
                "Error: Could not copy %s to %s: %s" % (
                    self.path, tmp_target, e))
            return False
        source_fp.close()
        tmp_target_fp.close()

        target = os.path.join(
            self._processor.maildir_base,
            maildir,
            "new",
            self._processor._create_maildir_name())
        self._processor._rename(tmp_target, target)

    def _delete(self):
        try:
            os.unlink(self.path)
        except OSError, e:
            # The file was probably moved.
            self._processor.log(
                "Error: Could not unlink %s: %s" % (self.path, e))

    def _forward(self, delete, addresses):
        if isinstance(addresses, basestring):
            addresses = [addresses]
        else:
            addresses = list(addresses)
        if delete:
            copy = ""
        else:
            copy = " copy"
        self._processor.log("==> Forwarding%s to %r" % (copy, addresses))
        try:
            source_fp = open(self.path)
        except IOError, e:
            # The file was probably moved.
            self._processor.log(
                "Error: Could not open %s: %s" % (self.path, e))
            return

        p = subprocess.Popen(
            "%s %s -- %s" % (
                self._processor.sendmail,
                self._processor.sendmail_flags,
                " ".join(addresses)
                ),
            shell=True,
            stdin=subprocess.PIPE)
        shutil.copyfileobj(source_fp, p.stdin)
        p.stdin.close()
        p.wait()
        source_fp.close()

        if delete:
            self._delete()


class MaildirProcessor(object):
    def __init__(self, log_fp=sys.stdout, dry_run=False, run_once=False):
        self._log_fp = log_fp
        self._run_once = run_once or dry_run
        self._maildir_base = None
        self._deliveries = 0
        self._maildirs = []
        self._sendmail = "/usr/sbin/sendmail"
        self._sendmail_flags = "-i"
        if dry_run:
            self._mail_class = DryRunMail
        else:
            self._mail_class = Mail

    def set_logfile(self, path_or_fp):
        if isinstance(path_or_fp, basestring):
            self._log_fp = open(os.path.expanduser(path_or_fp), "a")
        else:
            self._log_fp = path_or_fp
    logfile = property(fset=set_logfile)

    def get_maildir_base(self):
        return self._maildir_base
    def set_maildir_base(self, path):
        self._maildir_base = os.path.expanduser(path)
    maildir_base = property(get_maildir_base, set_maildir_base)

    def get_maildirs(self):
        return self._maildirs
    def set_maildirs(self, maildirs):
        self._maildirs = maildirs
    maildirs = property(get_maildirs, set_maildirs)

    def get_sendmail(self):
        return self._sendmail
    def set_sendmail(self, sendmail):
        self._sendmail = sendmail
    sendmail = property(get_sendmail, set_sendmail)

    def get_sendmail_flags(self):
        return self._sendmail_flags
    def set_sendmail_flags(self, sendmail_flags):
        self._sendmail_flags = sendmail_flags
    sendmail_flags = property(get_sendmail_flags, set_sendmail_flags)

    def __iter__(self):
        self.log("")
        self.log("Starting maildirproc at %s" % iso_8601_now())

        if self.maildir_base is None:
            self.log("Error: Maildir base directory not set")
            return

        if not self._maildirs:
            self.log("Error: No maildirs to process")
            return

        mtime_map = {}
        while True:
            for maildir in self._maildirs:
                maildir_path = os.path.join(self._maildir_base, maildir)
                for subdir in ["cur", "new"]:
                    subdir_path = os.path.join(maildir_path, subdir)
                    cur_mtime = os.path.getmtime(subdir_path)
                    if cur_mtime != mtime_map.setdefault(subdir_path, 0):
                        if cur_mtime < int(time.time()):
                            # If cur_mtime == int(time.time()) we
                            # can't be sure that everything has been
                            # processed; a new mail may be delivered
                            # later the same second.
                            mtime_map[subdir_path] = cur_mtime
                        for mail_file in os.listdir(subdir_path):
                            mail_path = os.path.join(subdir_path, mail_file)
                            yield self._mail_class(self, maildir, mail_path)
            if self._run_once:
                break
            time.sleep(1)

    def log(self, text):
        self._log_fp.write("%s\n" % text)
        self._log_fp.flush()

    # ----------------------------------------------------------------

    def _create_maildir_name(self):
        """Create and return a unique name for a Maildir message."""
        hostname = socket.gethostname()
        hostname = hostname.replace("/", "\\057")
        hostname = hostname.replace(":", "\\072")
        now = time.time()
        delivery_identifier = "M%dP%dQ%d" % (
            round((now - int(now)) * 1000000),
            os.getpid(),
            self._deliveries)
        self._deliveries += 1
        return "%d.%s.%s" % (now, delivery_identifier, hostname)

    def _rename(self, source, target):
        try:
            os.rename(source, target)
        except OSError, e:
            self.log(
                "Error: Could not rename %s to %s: %s" % (source, target, e))

######################################################################

def main(argv):
    default_rcfile_location = "~/.maildirprocrc"
    parser = OptionParser(
        version="0.1",
        description=(
            "maildirproc is a program that scans a number of maildir mail"
            " boxes and processes found mail as defined by a an rc file. See"
            " http://joel.rosdahl.net/maildirproc/ for more information."))
    parser.add_option(
        "-b",
        "--maildir-base",
        type="string",
        dest="maildir_base",
        metavar="DIRECTORY",
        help="set maildir base directory")
    parser.add_option(
        "--dry-run",
        action="store_true",
        default=False,
        help="just log what should have been done; implies --once")
    parser.add_option(
        "-l",
        "--logfile",
        type="string",
        dest="logfile",
        metavar="FILE",
        help="send log to LOGFILE instead of standard output",
        default=None)
    parser.add_option(
        "-m",
        "--maildir",
        action="append",
        type="string",
        default=[],
        dest="maildirs",
        metavar="NAME",
        help=(
            "add NAME (a subdirectory of the maildir base directory) to the"
            " set of maildir directories to process"))
    parser.add_option(
        "--once",
        action="store_true",
        default=False,
        help="only process the maildirs once and then exit")
    parser.add_option(
        "-r",
        "--rcfile",
        type="string",
        dest="rcfile",
        metavar="FILE",
        help=(
            "use the given rc file instead of the default (%s)" % (
                default_rcfile_location)),
        default=default_rcfile_location)
    (options, args) = parser.parse_args(argv[1:])

    if options.logfile is None:
        log_fp = sys.stdout
    else:
        log_fp = open(os.path.expanduser(options.logfile), "a")

    processor = MaildirProcessor(log_fp, options.dry_run, options.once)
    if options.maildir_base:
        processor.maildir_base = options.maildir_base
    if options.maildirs:
        processor.maildirs = options.maildirs
    if "SENDMAIL" in os.environ:
        processor.sendmail = os.environ["SENDMAIL"]
    if "SENDMAILFLAGS" in os.environ:
        processor.sendmail_flags = os.environ["SENDMAILFLAGS"]
    environment = {"processor": processor}
    try:
        if options.rcfile == "-":
            fp = sys.stdin
        else:
            fp = open(os.path.expanduser(options.rcfile))
    except IOError, e:
        processor.log("Error: Could not open RC file: %s" % e)
    else:
        exec fp in environment


if __name__ == "__main__":
    try:
        main(sys.argv)
    except KeyboardInterrupt:
        pass
